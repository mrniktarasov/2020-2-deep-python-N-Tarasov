import psycopg2
from HW4.DB_DATA import DB_DATA


class Integer:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if type(value) != int:
            raise ValueError('Must be integer')
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name


class String:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if type(value) != str:
            raise ValueError('Must be string')
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name


class Boolean:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if type(value) != bool:
            raise ValueError('Must be boolean')
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name


class Char:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if type(value) != str:
            raise ValueError('Must be boolean')
        if len(value) > instance.max_len:
            raise ValueError('Char overflow')
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name


class LineValidation:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if type(value) != tuple or type(value) != list:
            raise ValueError('Must be tuple  or list')
        if len(value) > len(self.__dict__.keys()):
            raise ValueError('Overflow')
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name


class Modules:
    class IntegerField:
        default = Integer()
        null = Boolean()

        def __init__(self, default=0, null=False):
            self.type = int
            if null:
                self.name = 'INTEGER'
            else:
                self.name = 'INTEGER NOT NULL'

    class TextField:
        default = String()

        def __init__(self, null=False, default=''):
            self.default = default
            self.type = str
            if null:
                self.name = 'TEXT'
            else:
                self.name = 'TEXT NOT NULL'

    class BooleanField:
        null = Boolean()
        default = Boolean()

        def __init__(self, null=False, default=False):
            self.default = default
            self.type = bool
            if null:
                self.name = 'BOOLEAN'
            else:
                self.name = 'BOOLEAN NOT NULL'

    class CharField:
        max_len = Integer()
        null = Boolean()

        def __init__(self, max_len=42, null=False):
            self.max_len = max_len
            self.type = 'char'
            if null:
                self.name = 'VARCHAR({0})'.format(max_len)
            else:
                self.name = 'VARCHAR({0}) NOT NULL'.format(max_len)

    class Module:
        id_field = 'id'
        id_count = 0
        row_types = []

        def _do_sql(self, command):
            con = psycopg2.connect(database=DB_DATA.db_name,
                                   user=DB_DATA.user,
                                   password=DB_DATA.password,
                                   host=DB_DATA.host)
            cursor = con.cursor()
            cursor.execute(command)
            con.commit()
            con.close()

        def _do_sql_with_return(self, command):
            con = psycopg2.connect(database=DB_DATA.db_name,
                                   user=DB_DATA.user,
                                   password=DB_DATA.password,
                                   host=DB_DATA.host)
            cursor = con.cursor()
            cursor.execute(command)
            con.commit()
            return cursor

        def create_table(self):
            command = 'CREATE TABLE {name} ({id} INT GENERATED BY DEFAULT AS IDENTITY, '.format(
                name=self.__class__.__name__,
                id=self.id_field
            )
            for key, value in self.__dict__.items():
                command += key + ' ' + value.name + ', '
                self.row_types.append(value)
            command = command[:-2] + ');'
            self._do_sql(command)

        def _make_command(self, command, tup):
            for value, cur_type in zip(tup, self.row_types):
                if self._isCorrectType(value, cur_type):
                    command += "'{0}', ".format(str(value))
                else:
                    raise ValueError('Char type {0} is overflow'.format(value))
            command = command[:-2] + ');'
            return command

        def _isCorrectType(self, value, cur_type):
            if type(value) == cur_type.type:
                return True
            try:
                if value.type == 'char':
                    if len(value) <= cur_type.max_length:
                        return True
                    else:
                        return False
            except AttributeError:
                raise ValueError('Value {0} is incorrect type'.format(value))

        def _make_cond_command(self, command, dic):
            for key, value in dic.items():
                command += "{0}='{1}', ".format(key, str(value))
            command = command[:-2] + ');'
            return command

        def add(self, values):
            self._is_list_or_tuple(values)
            self.id_count += 1
            command = 'INSERT INTO {tb_name} VALUES ({id}, '.format(
                tb_name=self.__class__.__name__,
                id=self.id_count
            )
            command = self._make_command(command, values)
            self._do_sql(command)

        def _is_list_or_tuple(self, values):
            if type(values) != tuple and type(values) != list:
                raise ValueError('Must be tuple  or list')
            if len(values) > len(self.__dict__.keys()):
                raise ValueError('Overflow')

        def get(self, **kwargs):
            command = 'SELECT * FROM {table_name} WHERE ('.format(table_name=self.__class__.__name__)
            command = self._make_cond_command(command, kwargs)
            cursor = self._do_sql_with_return(command)
            result = cursor.fetchone()
            cursor.close()
            return result

        def all(self):
            command = 'SELECT * FROM {table_name};'.format(table_name=self.__class__.__name__)
            cursor = self._do_sql_with_return(command)
            result = cursor.fetchall()
            cursor.close()
            return result

        def delete(self, **kwargs):
            command = 'DELETE FROM {table_name} WHERE ('.format(table_name=self.__class__.__name__)
            command = self._make_cond_command(command, kwargs)
            self._do_sql(command)

        def drop(self):
            command = 'DROP TABLE {0};'.format(self.__class__.__name__)
            self._do_sql(command)
